<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lijifeng168.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="序言弄明白对象、类、元类内存里存储的是什么东西就行">
<meta property="og:type" content="article">
<meta property="og:title" content="【Runtime】对象、类、元类、分类的本质">
<meta property="og:url" content="https://lijifeng168.com/2021/07/13/%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E3%80%81%E5%85%83%E7%B1%BB%E3%80%81%E5%88%86%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/index.html">
<meta property="og:site_name" content="个人技术生活分享">
<meta property="og:description" content="序言弄明白对象、类、元类内存里存储的是什么东西就行">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220713093308752.png">
<meta property="og:image" content="https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220713113333032.png">
<meta property="article:published_time" content="2021-07-13T01:31:03.000Z">
<meta property="article:modified_time" content="2022-07-17T03:04:42.884Z">
<meta property="article:author" content="lijifeng">
<meta property="article:tag" content="Runtime系列">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220713093308752.png">

<link rel="canonical" href="https://lijifeng168.com/2021/07/13/%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E3%80%81%E5%85%83%E7%B1%BB%E3%80%81%E5%88%86%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>【Runtime】对象、类、元类、分类的本质 | 个人技术生活分享</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">个人技术生活分享</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">文明其精神，野蛮其体魄</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lijifeng168.com/2021/07/13/%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E3%80%81%E5%85%83%E7%B1%BB%E3%80%81%E5%88%86%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/avatar.jpg">
      <meta itemprop="name" content="lijifeng">
      <meta itemprop="description" content="个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人技术生活分享">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【Runtime】对象、类、元类、分类的本质
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-13 09:31:03" itemprop="dateCreated datePublished" datetime="2021-07-13T09:31:03+08:00">2021-07-13</time>
            </span>

          
            <span id="/2021/07/13/%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E3%80%81%E5%85%83%E7%B1%BB%E3%80%81%E5%88%86%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/" class="post-meta-item leancloud_visitors" data-flag-title="【Runtime】对象、类、元类、分类的本质" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/07/13/%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E3%80%81%E5%85%83%E7%B1%BB%E3%80%81%E5%88%86%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/07/13/%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E3%80%81%E5%85%83%E7%B1%BB%E3%80%81%E5%88%86%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img src="https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220713093308752.png" alt="img"></p>
<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>弄明白对象、类、元类内存里存储的是什么东西就行</p>
<span id="more"></span>

<blockquote>
<p>一、对象的本质</p>
<p>二、类的本质</p>
<p>三、元类的本质</p>
<p>四、分类的本质</p>
</blockquote>
<blockquote>
<p>2006年苹果发布了OC2.0，其中对Runtime的很多API做了改进，并把OC1.0中Runtime的很多API标记为“将来会被废弃”。 但是两套API的核心实现思路还是一样的，而旧API比较简单，所以我们会分析旧API，然后看看新API作了哪些变化，这里有<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://opensource.apple.com/tarballs/objc4/">最新的Runtime源码</a>。</p>
</blockquote>
<h3 id="一、对象的本质"><a href="#一、对象的本质" class="headerlink" title="一、对象的本质"></a>一、对象的本质</h3><h4 id="1、OC1-0"><a href="#1、OC1-0" class="headerlink" title="1、OC1.0"></a>1、OC1.0</h4><p>通过查看RunTIme的源码（<code>objc.h</code>文件），我们得到对象的定义如下（伪代码）：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// 固定的成员变量</span></span><br><span class="line">    Class isa;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们自定义的成员变量</span></span><br><span class="line">    <span class="built_in">NSSring</span> *_name;</span><br><span class="line">    <span class="built_in">NSSring</span> *_sex;</span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="type">id</span>; <span class="comment">// id类型的本质就是一个objc_object类型的结构体指针，所以它可以指向任意一个OC对象</span></span><br></pre></td></tr></table></figure>

<p>可见对象的本质就是一个<code>objc_object</code>类型的结构体。该结构体内部只有一个固定的成员变量<code>isa</code>，它是一个<code>Class</code>类型的结构体指针，存储着一个地址，指向该对象所属的类。当然结构体内部还可能有很多我们自定义的成员变量，存储着该对象这些成员变量具体的值。</p>
<h4 id="2、OC2-0"><a href="#2、OC2-0" class="headerlink" title="2、OC2.0"></a>2、OC2.0</h4><p>通过查看Runtime的源码（<code>objc-private.h</code>文件），我们得到对象的定义如下（伪代码）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_object</span> &#123;</span><br><span class="line">    <span class="comment">// 固定的成员变量</span></span><br><span class="line">    <span class="type">isa_t</span> isa;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义的成员变量</span></span><br><span class="line">    NSSring *_name;</span><br><span class="line">    NSSring *_sex;</span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共用体isa_t</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 共用体也是C语言的一种数据类型，和结构体差不多，</span></span><br><span class="line"><span class="comment">// 都可以定义很多的成员变量，但两者的主要区别就在于内存的使用。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 一个结构体占用的内存等于它所有成员变量占用内存之和，而且要遵守内存对齐规则，而一个共用体占用的内存等于它最宽成员变量占用的内存。</span></span><br><span class="line"><span class="comment">// 结构体里所有的成员变量各自有各自的内存，而共用体里所有的成员变量共用这一块内存。</span></span><br><span class="line"><span class="comment">// 所以共用体可以更加节省内存，但是我们要把数据处理好，否则很容易出现数据覆盖。</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">isa_t</span> &#123;</span><br><span class="line">    Class cls;</span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bits; <span class="comment">// 8个字节，64位</span></span><br><span class="line">    <span class="keyword">struct</span> &#123; <span class="comment">// 其实所有的数据都存储在成员变量bits里面，因为外界只访问它，而这个结构体则仅仅是用位域来增加代码的可读性，让我们看到bits里面相应的位上存储着什么数据</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __arm64__</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> nonpointer        : <span class="number">1</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> has_assoc         : <span class="number">1</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> shiftcls          : <span class="number">33</span>; <span class="comment">// 当前对象所属类的地址信息</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> magic             : <span class="number">6</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> weakly_referenced : <span class="number">1</span>; <span class="comment">// 当前对象是否有弱引用</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> deallocating      : <span class="number">1</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> has_sidetable_rc  : <span class="number">1</span>; <span class="comment">// 引用计数表里是否有当前对象的引用计数</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> extra_rc          : <span class="number">19</span>; <span class="comment">// 对象的引用计数 - 1，存不下了就会放到引用计数表里</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_object</span> *id; <span class="comment">// id类型的本质就是一个objc_object类型的结构体指针，所以它可以指向任意一个OC对象</span></span><br></pre></td></tr></table></figure>

<p>可见对象的本质还是一个<code>objc_object</code>类型结构体。该结构体内部也还只有一个固定成员变量<code>isa</code>，只不过64位操作系统以后，对<code>isa</code>做了内存优化，它不再直接是一个指针，而是一个<code>isa_t</code>类型的共用体，它同样占用8个字节64位，但其中只有33位用来存储对象所属类的地址信息，还有19位用来存储（对象的引用计数 -1）、存储不下就放到引用计数表里，还有一位用来存储对象是否有弱引用，其他位上则存储这各种各样的标记信息。</p>
<ul>
<li><code>nonpointer</code>：占1位，标记<code>isa</code>是否经过内存优化。如果值为0，代表<code>isa</code>没经过内存优化，它就是一个普通的<code>isa</code>指针，64位全都用来存储该对象所属类的地址；如果值为1，代表<code>isa</code>经过了内存优化，只有33位用来存储对象所属类的地址信息，其它位则另有用途，了解一下即可；</li>
<li><code>has_assoc</code>：占1位，标记当前对象是否有关联对象，如果没有，对象销毁时会更快，了解一下即可；</li>
<li><code>has_cxx_dtor</code>：占1位，标记当前对象是否有C++析构函数，如果没有，对象销毁时会更快，了解一下即可；</li>
<li><strong><code>shiftcls</code>：占33位，存储着当前对象所属类的地址信息；</strong></li>
<li><code>magic</code>：占1位，用来标记在调试时当前对象是否未完成初始化，了解一下即可；</li>
<li><strong><code>weakly_referenced</code>：占1位，标记弱引用表里是否有当前对象的弱指针数组——即当前对象是否被弱指针指向着、当前对象是否有弱引用；</strong></li>
<li><code>deallocating</code>：占1位，标记当前对象是否正在释放，了解一下即可；</li>
<li><strong><code>has_sidetable_rc</code>：占1位，标记引用计数表里是否有当前对象的引用计数；</strong></li>
<li><strong><code>extra_rc</code>：占19位，存储着（对象的引用计数 - 1），存不下了就会放到引用计数表里，存值范围为0~255。</strong></li>
</ul>
<h3 id="二、类的本质"><a href="#二、类的本质" class="headerlink" title="二、类的本质"></a>二、类的本质</h3><h4 id="1、OC1-0-1"><a href="#1、OC1-0-1" class="headerlink" title="1、OC1.0"></a>1、OC1.0</h4><p>通过查看Runtime的源码（<code>runtime.h</code>文件），我们得到类的定义如下（伪代码）：<br>可见类的本质就是一个<code>objc_class</code>类型的结构体，该结构体内部有若干个成员变量，其中有几个是我们重点关注的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_class</span> &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    Class super_class;</span><br><span class="line"></span><br><span class="line">    <span class="type">method_array_t</span> methods;</span><br><span class="line">    <span class="type">property_array_t</span> properties;</span><br><span class="line">    <span class="type">protocol_array_t</span> protocols;</span><br><span class="line">    <span class="type">const</span> <span class="type">ivar_list_t</span> *ivars;</span><br><span class="line"></span><br><span class="line">    <span class="type">cache_t</span> cache;</span><br><span class="line">   </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">long</span> instance_size;</span><br><span class="line">    <span class="type">long</span> version;</span><br><span class="line">    <span class="type">long</span> info;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_class</span> *Class; <span class="comment">// Class类型的本质就是一个objc_class类型的结构体指针，所以它可以指向任意一个OC类</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>isa指针</code>：存储着一个地址，指向该类所属的类——即元类；</strong></li>
<li><strong><code>superclass指针</code>：存储着一个地址，指向该类的父类；</strong></li>
<li><strong><code>methods</code>：数组指针，存储着该类所有的实例方法信息；</strong></li>
<li><strong><code>properties</code>：数组指针，存储着该类所有的属性信息；</strong></li>
<li><strong><code>protocols</code>：数组指针，存储着该类所有遵守的协议信息；</strong></li>
<li><strong><code>ivars</code>：数组指针，存储着该类所有的成员变量信息；</strong></li>
<li><strong><code>cache</code>：结构体，存储着该类所有的方法缓存信息。</strong></li>
</ul>
<h4 id="2、OC2-0-1"><a href="#2、OC2-0-1" class="headerlink" title="2、OC2.0"></a>2、OC2.0</h4><p>通过查看Runtime的源码（<code>objc-runtime-new.h</code>文件），我们得到类的定义如下（伪代码）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">//    isa_t isa; // objc_class继承自objc_object，所以不考虑内存对齐的前提下，可以直接把isa成员变量搬过来</span><br><span class="line">    Class superclass;</span><br><span class="line">    </span><br><span class="line">    class_data_bits_t bits; // 存储着该类的具体信息，按位与掩码FAST_DATA_MASK便可得到class_rw_t</span><br><span class="line">    </span><br><span class="line">    cache_t cache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// class_rw_t结构体就是该类的可读可写信息（rw即readwrite）</span><br><span class="line">struct class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    const class_ro_t *ro; // 该类的只读信息</span><br><span class="line"></span><br><span class="line">    method_array_t methods; // 存储着该类所有的实例方法信息，包括分类的</span><br><span class="line">    property_array_t properties; // 存储着该类所有的属性信息，包括分类的</span><br><span class="line">    protocol_array_t protocols; // 存储着该类所有遵守的协议信息，包括分类的</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    char *demangledName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// class_ro_t结构体就是该类的只读信息（ro即readonly）</span><br><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    const uint8_t * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    const char * name;</span><br><span class="line">    method_list_t * baseMethodList; // 存储着该类本身的实例方法信息</span><br><span class="line">    protocol_list_t * baseProtocols; // 存储着该类本身遵守的协议信息</span><br><span class="line">    const ivar_list_t * ivars; // 存储着该类本身的成员变量信息</span><br><span class="line"></span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties; // 存储着该类本身的属性信息</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef struct objc_class *Class; // Class类型的本质就是一个objc_class类型的结构体指针，所以它可以指向任意一个OC类</span><br></pre></td></tr></table></figure>

<p>可见类的本质还是一个<code>objc_class</code>类型的结构体，我们重点关注的那几个成员变量还是可以顺利找到的，只不过它内部结构套了两层<code>rw</code>和<code>ro</code>，我们先说一下<code>ro</code>，<code>ro</code>内部存储着经过编译后一个类本身定义的所有实例方法、属性、协议、成员变量，它是只读的，然后运行时才会生成<code>rw</code>，把<code>ro</code>里类本身定义的所有实例方法、属性、协议搞到<code>rw</code>里，并把这个类所有分类的实例方法、属性、协议合并到<code>rw</code>里，<code>rw</code>是可读写的，这在解释“分类为什么不能给类扩展成员变量”提供了一个很好的证据。</p>
<h3 id="三、元类的本质"><a href="#三、元类的本质" class="headerlink" title="三、元类的本质"></a>三、元类的本质</h3><p>所谓元类，是指一个类所属的类，我们每创建一个类，系统就会自动帮我们创建好该类所属的类——即元类。如果你觉得不太好理解，这里就多说两句：我们常说“在面向对象编程里，万事万物皆对象”，因此在OC里对象其实分为实例对象、类对象、元类对象三类，我们开发中经常说的“对象”其实是指狭义的对象——实例对象，知道了这一点就好理解了，实例对象有它所属的类——即一个类对象，类对象也有它所属的类——即一个元类对象，元类对象也有它所属的类——即基类的元类对象。</p>
<p><strong>其实元类和类的本质都是<code>objc_class</code>结构体，只不过它们的用途不一样，类的<code>methods</code>成员变量里存储着该类所有的实例方法信息，而元类的<code>methods</code>成员变量里存储着该类所有的类方法信息。</strong></p>
<h3 id="四、分类的本质"><a href="#四、分类的本质" class="headerlink" title="四、分类的本质"></a>四、分类的本质</h3><h4 id="1、分类是什么，我们一般用分类做什么"><a href="#1、分类是什么，我们一般用分类做什么" class="headerlink" title="1、分类是什么，我们一般用分类做什么"></a>1、分类是什么，我们一般用分类做什么</h4><p><strong>分类是OC的一个高级特性，我们一般用它来给系统的类或三方库的类扩展方法、属性和协议，或者把一个类不同的功能分散到不同的模块里去实现。</strong></p>
<p>举个简单例子：</p>
<p>比如我们给<code>NSObject</code>类扩展一个<code>test</code>方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-----------<span class="built_in">NSObject</span>+INETest.h-----------</span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">INETest</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)ine_test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------<span class="built_in">NSObject</span>+INETest.m-----------</span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;NSObject+INETest.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">INETest</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)ine_test &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>比如我们有一个<code>INEPerson</code>类，保持它的主体，然后把它“吃”、“喝”的功能分散到不同的模块里去实现。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-----------INEPerson.h-----------</span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">INEPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------INEPerson.m-----------</span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;INEPerson.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">INEPerson</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-----------INEPerson+INEEat.h-----------</span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;INEPerson.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">INEPerson</span> (<span class="title">INEEat</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)ine_eat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------INEPerson+INEEat.m-----------</span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;INEPerson+INEEat.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">INEPerson</span> (<span class="title">INEEat</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)ine_eat &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-----------INEPerson+INEDrink.h-----------</span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;INEPerson.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">INEPerson</span> (<span class="title">INEDrink</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)ine_drink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------INEPerson+INEDrink.m-----------</span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;INEPerson+INEDrink.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">INEPerson</span> (<span class="title">INEDrink</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)ine_drink &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-----------ViewController.m-----------</span><br><span class="line"></span><br><span class="line">#<span class="keyword">import</span> <span class="string">&quot;INEPerson.h&quot;</span></span><br><span class="line">#<span class="keyword">import</span> <span class="string">&quot;INEPerson+INEEat.h&quot;</span></span><br><span class="line">#<span class="keyword">import</span> <span class="string">&quot;INEPerson+INEDrink.h&quot;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    INEPerson *person = [[INEPerson alloc] init];</span><br><span class="line">    [person ine_eat];<span class="comment">// INEPerson (INEEat) eat</span></span><br><span class="line">    [person ine_drink];<span class="comment">// INEPerson (INEDrink) drink</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>分类和延展的区别：</p>
<ul>
<li><strong>分类一般用来给系统的类或三方库的类扩展方法、属性和协议，或者把一个类不同的功能分散到不同的模块里去实现；而延展一般用来给我们自定义的类添加私有属性。</strong></li>
<li><strong>分类的数据不是在编译时就合并到类里面的，而是在运行时；而延展的数据是在编译时就合并到类里面的。</strong></li>
</ul>
</blockquote>
<h4 id="2、分类的本质"><a href="#2、分类的本质" class="headerlink" title="2、分类的本质"></a>2、分类的本质</h4><p>通过查看Runtime的源码（<code>objc-runtime-new.h</code>文件），我们得到分类的定义如下：（伪代码）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct category_t &#123;</span><br><span class="line">    const char *name; // 该分类所属的类的名字</span><br><span class="line">    struct classref *cls; // 指向该分类所属的类</span><br><span class="line">    struct method_list_t *instanceMethods;</span><br><span class="line">    struct method_list_t *classMethods;</span><br><span class="line">    struct protocol_list_t *protocols;</span><br><span class="line">    struct property_list_t *instanceProperties;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct category_t *Category;</span><br></pre></td></tr></table></figure>

<p>可见分类的本质是一个<code>category_t</code>类型的结构体，该结构体内部有若干个成员变量，其中有几个是我们重点关注的：</p>
<ul>
<li><strong><code>classMethods</code>：该分类为类扩展的类方法列表；</strong></li>
<li><strong><code>instanceMethods</code>：该分类为类扩展的实例方法列表；</strong></li>
<li><strong><code>instanceProperties</code>：该分类为类扩展的属性列表；</strong></li>
<li><strong><code>protocols</code>：该分类为类扩展的协议列表。</strong></li>
</ul>
<p>注意分类的本质里没有“该分类为类扩展的成员变量列表”喔，这在解释“为什么分类不能给类扩展成员变量”时又是一个很好的证据。</p>
<h4 id="3、分类的实现原理"><a href="#3、分类的实现原理" class="headerlink" title="3、分类的实现原理"></a>3、分类的实现原理</h4><p>我们知道一个类所有的实例方法都存储在类里面，所有的类方法都存储在元类里面，而对象调用方法的流程就是根据<code>isa</code>指针先找到相应的类或元类，然后在类或元类里再找到相应的方法来调用，那<code>person</code>对象是怎么找到分类里的<code>ine_eat</code>和<code>ine_drink</code>方法来调用的呢？</p>
<p>现在我们可以大胆猜测，因为对象内部只有一个<code>isa</code>指针，指向它所属的类，所以不可能再有一套类似的方法查找机制让它专门去分类里面查找方法，难道系统会把分类里的方法合并到类里面去？如果会合并的话，那是编译时合并的，还是运行时合并的？很简单，我们只需要看看编译后类里面是否已经包含了分类的方法就行。</p>
<blockquote>
<p>先给出结论：<strong>系统不是在编译时让编译器把分类的数据合并到类、元类里面的，而是在运行时利用Runtime动态把分类的数据合并到类、元类里面的，而且分类的数据还放在类本身数据的前面，越晚编译的分类越在前面，所以如果分类里面有和类里面同名的方法，会优先调用分类里面的方法，如果多个分类里面有同名的方法，会优先调用后编译分类里面的方法，我们可以去Compile Sources里控制分类编译的顺序。</strong></p>
</blockquote>
<ul>
<li>系统不是在编译时让编译器把分类的数据合并到类、元类里面的</li>
</ul>
<p>接着上面<code>INEPerson</code>类的例子，我们用<code>clang</code>编译器把<code>INEPerson.m</code>文件转换成C/C++代码，以便窥探编译后<code>INEPerson</code>类里面是否已经包含了分类的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class OBJC_CLASS_$_INEPerson = &#123;</span><br><span class="line">    0, // &amp;OBJC_METACLASS_$_INEPerson,</span><br><span class="line">    0, // &amp;OBJC_CLASS_$_NSObject,</span><br><span class="line">    0, // (void *)&amp;_objc_empty_cache,</span><br><span class="line">    </span><br><span class="line">    // 可读可写的</span><br><span class="line">    [&quot;age&quot;, &quot;setAge:&quot;], // 所有的实例方法</span><br><span class="line">    [&quot;age&quot;], // 所有的属性</span><br><span class="line">    [], // 所有遵循的协议</span><br><span class="line">    </span><br><span class="line">    // 只读的</span><br><span class="line">    &quot;INEPerson&quot;, // 类名</span><br><span class="line">    [&quot;_age&quot;], // 所有的成员变量</span><br><span class="line">    16, // 实例对象的实际大小</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可见经过编译后，<code>INEPerson</code>类里面的数据还是它本身拥有的那些数据，并没有分类的方法，这就表明系统不是在编译时让编译器把分类的数据合并到类、元类里面的。</p>
<ul>
<li>而是在运行时利用Runtime动态把分类的数据合并到类、元类里面的</li>
</ul>
<p>既然系统不是在编译时就把分类的数据合并到类里面的，那就只能是在运行时了，接下来我们就找找运行时（Runtime）的相关源码（<code>objc-runtime-new.mm</code>文件），看看系统到底是怎么把分类合并到类里面的：</p>
<p>运行时，系统读取镜像阶段，会读取所有的类，并且如果发现有分类，也会读取所有的分类，然后遍历所有的分类，根据分类的<code>cls指针</code>找到它所属的类，重新组织一下这个类的内部结构——即合并分类的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 系统读取镜像</span><br><span class="line">void _read_images()</span><br><span class="line">&#123;</span><br><span class="line">    // 读取所有的类</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    // 发现有分类</span><br><span class="line">    // 读取所有的分类</span><br><span class="line">    category_t **catlist = _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">    // 遍历所有的分类</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        // 读取某一个分类</span><br><span class="line">        category_t *cat = catlist[I];</span><br><span class="line">        </span><br><span class="line">        // 根据分类的cls指针找到它所属的类</span><br><span class="line">        Class cls = cat-&gt;cls;</span><br><span class="line">        // 重新组织一下这个类的内部结构——即合并分类的数据</span><br><span class="line">        remethodizeClass(cls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那具体怎么个合并法呢？<strong>系统会去获取这个类所有的分类，然后倒序遍历这所有的分类，把每个分类里面的实例方法列表拿出来，存进一个二维数组里</strong>（因为是倒序遍历分类的，所以越晚编译的分类的实例方法列表反而越会放在二维数组的前面），<strong>然后再把这个二维数组内所有一维数组的首地址复制进<code>methods</code>成员变量指向的那块内存里（注意这个存储过程会把类本身的实例方法列表挪到最后——即高内存地址上，而把分类的实例方法列表存在前面）。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">// 重新组织一下这个类的内部结构——即合并分类的数据</span><br><span class="line">static void remethodizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    // 系统会去获取这个类所有的分类（没有合并过的）</span><br><span class="line">    category_list *cats = unattachedCategoriesForClass(cls);</span><br><span class="line">    // 把所有分类的数据合并到类里面</span><br><span class="line">    attachCategories(cls, cats);</span><br><span class="line">    free(cats);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 把所有分类的数据合并到类里面</span><br><span class="line"> *</span><br><span class="line"> * @param cls 当前类</span><br><span class="line"> * @param cats 当前类所有的分类</span><br><span class="line"> */</span><br><span class="line">static void attachCategories(Class cls, category_list *cats)</span><br><span class="line">&#123;</span><br><span class="line">#pragma mark - 倒序遍历所有的分类，把每个分类里面的实例方法列表拿出来，存进一个二维数组里</span><br><span class="line">    /*</span><br><span class="line">     创建一个二维数组，用来存放每个分类里的实例方法列表，最终结果类似下面这样：</span><br><span class="line">     [</span><br><span class="line">        [instanceMethod1, instanceMethod2, ...] --&gt; 分类1所有实例方法</span><br><span class="line">        [instanceMethod1, instanceMethod2, ...] --&gt; 分类2所有实例方法</span><br><span class="line">        ...</span><br><span class="line">     ]</span><br><span class="line">     */</span><br><span class="line">    method_list_t **mlists = (method_list_t **) malloc(cats-&gt;count * sizeof(*mlists));</span><br><span class="line">    </span><br><span class="line">    // 属性</span><br><span class="line">    property_list_t **proplists = (property_list_t **) malloc(cats-&gt;count * sizeof(*proplists));</span><br><span class="line">    </span><br><span class="line">    // 协议</span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **) malloc(cats-&gt;count * sizeof(*protolists));</span><br><span class="line">    </span><br><span class="line">    int mcount = 0;</span><br><span class="line">    int propcount = 0;</span><br><span class="line">    int protocount = 0;</span><br><span class="line">    int i = cats-&gt;count;</span><br><span class="line">    // 注意：这里是倒序遍历所有的分类</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">        // 获取一个分类</span><br><span class="line">        auto cat = cats[I];</span><br><span class="line">        </span><br><span class="line">        // 获取分类的实例方法列表，存进二维数组</span><br><span class="line">        method_list_t *mlist = cat-&gt;methods;</span><br><span class="line">        mlists[mcount++] = mlist;</span><br><span class="line">        </span><br><span class="line">        // 属性</span><br><span class="line">        protocol_list_t *protolist = cat-&gt;protocols;</span><br><span class="line">        protolists[protocount++] = protolist;</span><br><span class="line">        </span><br><span class="line">        // 协议</span><br><span class="line">        property_list_t *proplist = cat-&gt;properties;</span><br><span class="line">        proplists[propcount++] = proplist;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">#pragma mark - 把这个二维数组内所有一维数组的首地址存进methods成员变量所指向的那块内存空间里</span><br><span class="line">    </span><br><span class="line">    // 获取当前类的数据（包括实例方法列表、属性列表、协议列表等）</span><br><span class="line">    auto classData = cls-&gt;data();</span><br><span class="line">    </span><br><span class="line">    // 给当前类的实例方法列表附加所有分类的实例方法列表</span><br><span class="line">    classData-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    free(mlists);</span><br><span class="line">    </span><br><span class="line">    // 属性</span><br><span class="line">    classData-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    free(proplists);</span><br><span class="line">    </span><br><span class="line">    // 协议</span><br><span class="line">    classData-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    free(protolists);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 给当前类的实例方法列表附加所有分类的实例方法列表</span><br><span class="line"> *</span><br><span class="line"> * @param addedLists 所有分类的实例方法列表（就是那个二维数组，但其实是那个二维数组的首地址）</span><br><span class="line"> * @param addedCount 分类的个数</span><br><span class="line"> */</span><br><span class="line">void attachLists(List* const * addedLists, unsigned int addedCount) &#123;</span><br><span class="line">#pragma mark - 重新为类的methods成员变量分配内存</span><br><span class="line">    // 获取类原来methods成员变量的元素个数（注意：一个类的methods成员变量是一个数组，存储着若干个指针，指向相应的方法列表，而不是直接就是个方法列表存储方法）</span><br><span class="line">    unsigned int oldCount = array()-&gt;count;</span><br><span class="line">    // 加上分类的个数，得到新的methods成员变量该有多少个元素</span><br><span class="line">    unsigned int newCount = oldCount + addedCount;</span><br><span class="line">    // 重新为methods成员变量所指向的数组分配内存，一个指针占8个字节</span><br><span class="line">    setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">    array()-&gt;count = newCount;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">#pragma mark - 为类的methods成员变量重新分配完内存后，对其内存数据进行移动和复制操作</span><br><span class="line">    //</span><br><span class="line">    /*</span><br><span class="line">     内存复制：</span><br><span class="line">     memmove(dst, src, len)，从src所指向的内存空间复制len个字节的数据到dst所指向的内存空间，内部处理了内存覆盖。</span><br><span class="line">     memcpy(dst, src, n)，从src所指向的内存空间复制n个字节的数据到dst所指向的内存空间，内部没处理内存覆盖。</span><br><span class="line">     */</span><br><span class="line">    // 把类原来的实例方法列表复制到最后面（但其实是把类原来的实例方法列表，在methods成员变量里对应的那个指针————原来的实例方法列表的首地址————复制到最后面了）</span><br><span class="line">    memmove(array()-&gt;lists + addedCount, array()-&gt;lists,</span><br><span class="line">            oldCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">    // 把所有分类的实例方法列表放在前面（同理，其实是把所有分类的的实例方法列表的首地址复制到前面了，因为methods成员变量里存放的是指针————即实例方法列表的地址，不过这里二维数组的内存拷贝会拷贝它里面所有一维数组的首地址，而不仅仅这个二维数组的首地址）</span><br><span class="line">    memcpy(array()-&gt;lists, addedLists,</span><br><span class="line">           addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就把所有分类的实例方法列表全都合并到类里面去了，最终类的方法列表结构如下：</p>
<p><img src="https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220713113333032.png" alt="img"></p>
<p>以上我们只是说明了分类为类扩展实例方法的底层实现，至于分类为类扩展类方法、属性、协议是同理的。</p>
<h4 id="4、分类的-load方法和-initialize方法"><a href="#4、分类的-load方法和-initialize方法" class="headerlink" title="4、分类的+load方法和+initialize方法"></a>4、分类的<code>+load</code>方法和<code>+initialize</code>方法</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">调用时机</th>
<th align="center">调用方式</th>
<th align="center">调用顺序</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>+load</code>方法</td>
<td align="center"><code>+load</code>方法是系统把类和分类载入内存时调用的</td>
<td align="center"><code>+load</code>方法是通过内存地址直接调用的，所以分类的<code>+load</code>方法不会覆盖类的<code>+load</code>方法，也就是说如果类和分类里面都实现了<code>+load</code>方法，那么它们都会被调用</td>
<td align="center">会先调用所有类的<code>+load</code>方法，然后再调用所有分类的<code>+load</code>方法</td>
</tr>
<tr>
<td align="center"><code>+initialize</code>方法</td>
<td align="center"><code>+initialize</code>方法是类初始化的时候调用的</td>
<td align="center"><code>+initialize</code>方法是通过消息发送机制调用的，所以分类的<code>+initialize</code>方法会覆盖类的<code>+initialize</code>方法，也就是说如果类和分类里面都实现了<code>+initialize</code>方法，那么只有分类里面的会被调用</td>
<td align="center">会优先调用分类的<code>+initialize</code>方法</td>
</tr>
</tbody></table>
<blockquote>
<p>苹果提供类、分类的<code>+load</code>方法和<code>+initialize</code>方法，其实就是给我们开发者暴露两个接口，让我们根据这俩方法的特点来合理使用。比如我们想在某个类被载入内存时做一些事情，就可以在<code>+load</code>方法里做操作，想在某个类初始化时做一些事情，就可以在<code>+initialize</code>方法里做操作。</p>
</blockquote>
<h6 id="4-1-load方法"><a href="#4-1-load方法" class="headerlink" title="4.1 +load方法"></a>4.1 <code>+load</code>方法</h6><ul>
<li>调用时机</li>
</ul>
<p>假设有一个<code>INEPerson</code>类，并且为它创建了两个分类<code>INEEat</code>和<code>INEDrink</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">-----------INEPerson.m-----------</span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;INEPerson.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">INEPerson</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;INEPerson +load&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------INEPerson+INEEat.m-----------</span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;INEPerson+INEEat.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">INEPerson</span> (<span class="title">INEEat</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;INEPerson (INEEat) +load&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------INEPerson+INEDrink.m-----------</span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;INEPerson+INEDrink.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">INEPerson</span> (<span class="title">INEDrink</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;INEPerson (INEDrink) +load&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>我们什么都不做，不使用<code>Person</code>类，甚至连它的头文件也不导入。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---------<span class="attr">--ViewController</span><span class="selector-class">.m-----------</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#import</span> &quot;ViewController<span class="selector-class">.h</span>&quot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@implementation</span> ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    <span class="selector-attr">[super viewDidLoad]</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>直接运行程序，发现控制台打印如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INEPerson +load</span><br><span class="line">INEPerson (INEEat) +load</span><br><span class="line">INEPerson (INEDrink) +load</span><br></pre></td></tr></table></figure>

<p>于是我们就可以得出结论：**<code>+load</code>方法是系统把类和分类载入内存时调用的，<strong>它和我们代码里使用不使用这个类和分类无关。并且因为<code>+load</code>方法只会在类和分类被载入内存时调用，所以</strong>每个类和分类的<code>+load</code>方法在程序的整个生命周期中肯定会被调用且只调用一次。**</p>
<ul>
<li>调用方式</li>
</ul>
<p>这里先回想一下，上面第三部分我们说过<strong>分类的方法列表会合并到类本身的方法列表里，并且分类的方法列表还会在类本身方法列表的前面，</strong>因此分类的方法会覆盖掉类里同名的方法。</p>
<p>但不知道你注意没有，上面第1小节的例子，控制台打印了三个东西，也就是说分类的<code>+load</code>方法和类的<code>+load</code>方法都走了，这很奇怪啊，按理说应该只走其中某一个分类的<code>+load</code>方法才对啊，怎么会三个都走呢？也就是说为什么分类的<code>+load</code>方法没有覆盖掉类的<code>+load</code>方法？</p>
<p>接下来我们就找找运行时（Runtime）的相关源码（<code>objc-runtime-new.mm</code>文件），看看能不能得到答案：（伪代码）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统加载镜像</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">load_images</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">call_load_methods</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用+load方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_load_methods</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1、首先调用所有类的+load方法</span></span><br><span class="line">    <span class="built_in">call_class_loads</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、然后调用所有分类的+load方法</span></span><br><span class="line">    <span class="built_in">call_category_loads</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用所有类的+load方法</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">call_class_loads</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取到所有的类</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">loadable_class</span> *classes = loadable_classes;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; loadable_classes_used; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取到某个类</span></span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        <span class="comment">// 获取到某个类+load方法的地址</span></span><br><span class="line">        <span class="type">load_method_t</span> load_method = (<span class="type">load_method_t</span>)classes[i].method;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 直接调用该类的+load方法</span></span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用所有分类的+load方法</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">call_category_loads</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取到所有的分类</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">loadable_category</span> *cats = loadable_categories;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loadable_categories_used; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取到某个分类</span></span><br><span class="line">        Category cat = cats[i].cat;</span><br><span class="line">        <span class="comment">// 获取到某个分类+load方法的地址</span></span><br><span class="line">        <span class="type">load_method_t</span> load_method = (<span class="type">load_method_t</span>)cats[i].method;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接调用该分类的+load方法</span></span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见**<code>+load</code>方法是通过内存地址直接调用的，<strong>而不像普通方法那样走消息发送机制。因此就解释了我们留下的疑惑，虽然说分类的方法列表在类本身方法列表的前面，但是对<code>+load</code>方法根本不起作用，人家不走你那一套，</strong>所以分类的<code>+load</code>方法不会覆盖类的<code>+load</code>方法。**</p>
<ul>
<li>调用顺序</li>
</ul>
<p>这里就直接给出结论了，感兴趣的话，可以像第2小节那样去看源码（核心代码就集中在上面那几个方法里）并敲代码验证验证。</p>
<p><strong>会先调用所有类的<code>+load</code>方法，先编译的类先调用；如果存在继承关系，那么在调用子类的<code>+load</code>方法之前会先去调用父类的<code>+load</code>方法。</strong></p>
<p><strong>然后再调用所有分类的<code>+load</code>方法，先编译的分类先调用。</strong></p>
<h6 id="4-2-initialize方法"><a href="#4-2-initialize方法" class="headerlink" title="4.2 +initialize方法"></a>4.2 <code>+initialize</code>方法</h6><ul>
<li>调用时机</li>
</ul>
<p>假设有一个<code>INEPerson</code>类和一个继承自<code>INEPerson</code>类的<code>INEStudent</code>类，并且为<code>INEStudent</code>类创建了两个分类<code>INEEat</code>和<code>INEDrink</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">-----------INEPerson.m-----------</span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;INEPerson.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">INEPerson</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;INEPerson +initialize&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------INEStudent.m-----------</span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;INEStudent.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">INEStudent</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;INEStudent +initialize&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------INEStudent+INEEat.m-----------</span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;INEStudent+INEEat.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">INEStudent</span> (<span class="title">INEEat</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;INEStudent (INEEat) +initialize&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------INEStudent+INEDrink.m-----------</span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;INEStudent+INEDrink.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">INEStudent</span> (<span class="title">INEDrink</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;INEStudent (INEDrink) +initialize&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>我们什么都不做，直接运行程序，发现控制台什么都没打印。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---------<span class="attr">--ViewController</span><span class="selector-class">.m-----------</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#import</span> &quot;ViewController<span class="selector-class">.h</span>&quot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@implementation</span> ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    <span class="selector-attr">[super viewDidLoad]</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>此时我们调用一下<code>Student</code>类的<code>+alloc</code>方法。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">---------<span class="attr">--ViewController</span><span class="selector-class">.m-----------</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#import</span> &quot;ViewController<span class="selector-class">.h</span>&quot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@implementation</span> ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    <span class="selector-attr">[super viewDidLoad]</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-attr">[INEStudent alloc]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>运行程序，发现控制台打印如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INEPerson +initialize</span><br><span class="line">INEStudent (INEDrink) +initialize</span><br></pre></td></tr></table></figure>

<p>于是我们就可以得出结论：**<code>+initialize</code>方法是类初始化的时候调用的，<strong>所以严格地来讲，我们不能说“<code>+initialize</code>方法是第一次使用类的时候调用的”，你看上面例子中我们根本没使用<code>INEPerson</code>类嘛，但它的<code>+initialize</code>方法照样被调用了。</strong>如果我们压根儿不使用这个类，它的<code>+initialize</code>方法被调用0次，但是我们不能说一个类的<code>+initialize</code>方法最多被调用1次，因为<code>+initialize</code>方法是通过消息发送机制来调用的，如果好几个子类都继承自某一个类，而这些子类都没有实现自己的<code>+initialize</code>方法，那就都会去调用这个父类的<code>+initialize</code>方法，这不就是调用N次了嘛。**</p>
<ul>
<li>调用方式</li>
</ul>
<p>上面第1小节的例子，控制台打印了一个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INEStudent (INEDrink) +initialize</span><br></pre></td></tr></table></figure>

<p>这就明显表明：**<code>+initialize</code>方法的调用方式不同于<code>+load</code>方法，它是通过消息发送机制调用的，所以才会只走分类里面的 <code>+initialize</code>方法，也就是说分类的<code>+initialize</code>方法会覆盖类的<code>+initialize</code>方法。**</p>
<p>但有一点很奇怪，因为控制台还打印了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INEPerson +initialize</span><br></pre></td></tr></table></figure>

<p>这是父类的<code>+initialize</code>方法呀！既然<code>+initialize</code>方法是通过消息发送机制调用的，那它在自己类的内部找到某个方法后，就不应该再调用父类里面的方法了呀，怎么回事？</p>
<p>接下来我们就找找运行时（Runtime）的相关源码（<code>objc-runtime-new.mm</code>文件），看看能不能得到答案：（伪代码）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找方法的实现：类接收到消息后，会去查找这个消息的实现并调用，那我们就从查找这个消息的实现下手吧，前面的源码没有相关信息</span></span><br><span class="line"><span class="function">IMP <span class="title">lookUpImpOrForward</span><span class="params">(Class cls, SEL sel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 在查找方法的过程中，如果发现这个类没被初始化过</span></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;<span class="built_in">isInitialized</span>()) &#123;</span><br><span class="line">        <span class="comment">// 则初始化这个类</span></span><br><span class="line">        <span class="built_in">initializeNonMetaClass</span>(cls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initializeNonMetaClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 在初始化一个类的过程中</span></span><br><span class="line">    Class supercls = cls-&gt;superclass;</span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !supercls-&gt;<span class="built_in">isInitialized</span>()) &#123;<span class="comment">// 如果发现这个类的父类没被初始化过</span></span><br><span class="line">        <span class="comment">// 则递归，一层一层地先初始化父类，直到NSObject，直到nil</span></span><br><span class="line">        <span class="built_in">initializeNonMetaClass</span>(supercls);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一层一层初始化完之后，才会一层一层自上而下地调用各个类的+initialize方法</span></span><br><span class="line">        <span class="built_in">callInitialize</span>(cls);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果发现这个类的父类被初始化过了</span></span><br><span class="line">        <span class="comment">// 则直接初始化自己</span></span><br><span class="line">        <span class="built_in">initializeNonMetaClass</span>(cls);</span><br><span class="line">        <span class="comment">// 并调用自己的+initialize方法，</span></span><br><span class="line">        <span class="comment">// 如果自己没有实现，则会去找父类的+initialize方法调用。（因为+initialize方法是通过消息发送机制调用的嘛）</span></span><br><span class="line">        <span class="built_in">callInitialize</span>(cls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callInitialize</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// +initialize方法确实是通过消息发送机制调用的</span></span><br><span class="line">    ((<span class="built_in">void</span>(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见<strong>系统在调用一个类的<code>+initialize</code>方法之前，首先会看看它的父类初始化了没有，如果没有初始化，则初始化它的父类并调用它父类的<code>+initialize</code>方法，然后再初始化自己并调用自己的<code>+initialize</code>方法；如果它的父类初始化了，则直接初始化自己并调用自己的<code>+initialize</code>方法，如果自己没有实现，则会去找父类的<code>+initialize</code>方法调用。</strong></p>
<ul>
<li>调用顺序</li>
</ul>
<p>这里就直接给出结论了。</p>
<p><strong>系统在调用一个类的<code>+initialize</code>方法之前，首先会看看它的父类初始化了没有，如果没有初始化，则初始化它的父类并调用它父类的<code>+initialize</code>方法，然后再初始化自己并调用自己的<code>+initialize</code>方法；如果它的父类初始化了，则直接初始化自己并调用自己的<code>+initialize</code>方法，如果自己没有实现，则会去找父类的<code>+initialize</code>方法调用。</strong></p>
<p><strong>如果分类里也实现了<code>+initialize</code>方法，会优先调用分类的。</strong></p>
<h3 id="temp、行文至此，我们举个例子串一下上面的内容"><a href="#temp、行文至此，我们举个例子串一下上面的内容" class="headerlink" title="temp、行文至此，我们举个例子串一下上面的内容"></a>temp、行文至此，我们举个例子串一下上面的内容</h3><p>定义一个<code>INEPerson</code>类，并为它创建一个分类<code>INEDrink</code>，然后创建两个<code>person</code>对象。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">-----------INEPerson.h-----------</span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">INEPerson</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *sex;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)eat;</span><br><span class="line">+ (<span class="type">void</span>)sleep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------INEPerson.m-----------</span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;INEPerson.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">INEPerson</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)eat &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;对象方法：吃&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)sleep &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;类方法：睡&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)copyWithZone:(<span class="keyword">nullable</span> <span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    <span class="comment">// 浅拷贝一下</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>



<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">-----------INEPerson+INEDrink.h-----------</span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;INEPerson.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">INEPerson</span> (<span class="title">INEDrink</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)ine_drinkWater;</span><br><span class="line">+ (<span class="type">void</span>)ine_drinkTea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------INEPerson+INEDrink.m-----------</span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;INEPerson+INEDrink.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">INEPerson</span> (<span class="title">INEDrink</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)ine_drinkWater &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)ine_drinkTea &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>



<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">-----------ViewController.m-----------</span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;INEPerson.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    INEPerson *person1 = [[INEPerson alloc] init];</span><br><span class="line">    person1.name = <span class="string">@&quot;张三&quot;</span>;</span><br><span class="line">    person1.sex = <span class="string">@&quot;男&quot;</span>;</span><br><span class="line">    person1.age = <span class="number">19</span>;</span><br><span class="line">    [person1 eat];</span><br><span class="line">    </span><br><span class="line">    INEPerson *person2 = [[INEPerson alloc] init];</span><br><span class="line">    person2.name = <span class="string">@&quot;李四&quot;</span>;</span><br><span class="line">    person2.sex = <span class="string">@&quot;女&quot;</span>;</span><br><span class="line">    person2.age = <span class="number">18</span>;</span><br><span class="line">    </span><br><span class="line">    [INEPerson sleep];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>当我们启动App时，系统就会把<code>INEPerson</code>类、<code>INEPerson</code>类的元类还有<code>INEPerson</code>类的分类加载到内存中，然后把分类的数据合并到类和元类里，并且这些类会被存储到静态全局区，因为类只要一份就够了嘛 + 类还得能在项目的任何地方都能访问到，直到杀死App，这些类的内存才会被释放。那么<code>INEPerson</code>类在静态全局区的那块内存里存储着什么呢？<code>isa</code>指针存储着一个地址，指向<code>INEPerson</code>类的元类，这个地址就是<code>INEPerson</code>类的元类在静态全局区的内存地址；<code>superClass</code>指针存储着一个地址，指向<code>NSObject</code>类，这个地址就是<code>NSObject</code>类在静态全局区的内存地址；<code>methods</code>成员变量存储着<code>ine_drinkWater</code>和<code>eat</code>这两个实例方法的信息，<code>properties</code>成员变量存储着<code>name</code>、<code>sex</code>、<code>age</code>这些属性的信息，<code>protocols</code>成员变量存储着<code>NSCopying</code>协议的信息，<code>ivars</code>成员变量存储着<code>_name</code>、<code>_sex</code>、<code>_age</code>这些成员变量的信息，<code>cache</code>缓存着<code>eat</code>方法的信息。<code>INEPerson</code>类的元类在静态全局区的那块内存里存储着什么呢？<code>isa</code>指针存储着一个地址，指向基类<code>NSObject</code>类的元类，这个地址就是基类<code>NSObject</code>类的元类在静态全局区的内存地址；<code>superClass</code>指针存储着一个地址，同样指向基类<code>NSObject</code>类的元类，这个地址就是基类<code>NSObject</code>类的元类在静态全局区的内存地址；<code>methods</code>成员变量存储着<code>ine_drinkTea</code>和<code>sleep</code>这个类方法的信息，<code>cache</code>缓存着<code>sleep</code>方法的信息。</p>
<p>当我们<code>alloc init</code>一个<code>person</code>对象时，就会在堆区分配一块内存，直到没有强引用引用这个对象了，这块内存才会被释放。那么<code>person</code>对象在堆区的那块内存里存储着什么呢？<code>isa</code>指针存储着一个地址，指向<code>INEPerson</code>类，这个地址就是<code>INEPerson</code>类在静态全局区的内存地址；<code>person1</code>对象接下来会存储<code>_name</code>成员变量的值”张三”，当然它存储的也是一个常量区的地址，指向”张三”这个字符串常量，还有<code>_sex</code>成员变量的值”男”，当然它存储的也是一个常量区的地址，指向”男”这个字符串常量，还有<code>_age</code>成员变量的值“19”，当然“19”就是直接存储了，因为它是个立即数；<code>person2</code>对象接下来则会存储<code>_name</code>成员变量的值”李四”，<code>_sex</code>成员变量的值”女”，<code>_age</code>成员变量的值“18”，注意对象的内存里存储的是成员变量的值，而类的内存里存储的是成员变量的信息——比如<code>INEPerson</code>类有一个成员变量是“_name”，它的类型是<code>NSString</code>这样。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Runtime%E7%B3%BB%E5%88%97/" rel="tag"># Runtime系列</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/12/Runtime%EF%BC%9Aisa%E6%8C%87%E9%92%88%E5%92%8CsuperClass%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E5%90%91%EF%BC%8Cmethods%E3%80%81cache%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E8%AF%A6%E8%A7%A3/" rel="prev" title="【Runtime】isa指针和superClass指针的指向，methods、cache成员变量详解">
      <i class="fa fa-chevron-left"></i> 【Runtime】isa指针和superClass指针的指向，methods、cache成员变量详解
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/07/13/Runtime%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/" rel="next" title="【Runtime】Runtime是什么？">
      【Runtime】Runtime是什么？ <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">序言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">2.</span> <span class="nav-text">一、对象的本质</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81OC1-0"><span class="nav-number">2.1.</span> <span class="nav-text">1、OC1.0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81OC2-0"><span class="nav-number">2.2.</span> <span class="nav-text">2、OC2.0</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">3.</span> <span class="nav-text">二、类的本质</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81OC1-0-1"><span class="nav-number">3.1.</span> <span class="nav-text">1、OC1.0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81OC2-0-1"><span class="nav-number">3.2.</span> <span class="nav-text">2、OC2.0</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%85%83%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">4.</span> <span class="nav-text">三、元类的本质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%88%86%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">5.</span> <span class="nav-text">四、分类的本质</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%88%86%E7%B1%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%88%91%E4%BB%AC%E4%B8%80%E8%88%AC%E7%94%A8%E5%88%86%E7%B1%BB%E5%81%9A%E4%BB%80%E4%B9%88"><span class="nav-number">5.1.</span> <span class="nav-text">1、分类是什么，我们一般用分类做什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%88%86%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">5.2.</span> <span class="nav-text">2、分类的本质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%88%86%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">5.3.</span> <span class="nav-text">3、分类的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%88%86%E7%B1%BB%E7%9A%84-load%E6%96%B9%E6%B3%95%E5%92%8C-initialize%E6%96%B9%E6%B3%95"><span class="nav-number">5.4.</span> <span class="nav-text">4、分类的+load方法和+initialize方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#4-1-load%E6%96%B9%E6%B3%95"><span class="nav-number">5.4.0.1.</span> <span class="nav-text">4.1 +load方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-2-initialize%E6%96%B9%E6%B3%95"><span class="nav-number">5.4.0.2.</span> <span class="nav-text">4.2 +initialize方法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#temp%E3%80%81%E8%A1%8C%E6%96%87%E8%87%B3%E6%AD%A4%EF%BC%8C%E6%88%91%E4%BB%AC%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%E4%B8%B2%E4%B8%80%E4%B8%8B%E4%B8%8A%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-number">6.</span> <span class="nav-text">temp、行文至此，我们举个例子串一下上面的内容</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lijifeng"
      src="https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/avatar.jpg">
  <p class="site-author-name" itemprop="name">lijifeng</p>
  <div class="site-description" itemprop="description">个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://carlwe.com/" title="https:&#x2F;&#x2F;carlwe.com&#x2F;" rel="noopener" target="_blank">carlwe</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">晋ICP备2022005502号 </a>
      <img src="https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/policebeian.png" style="display: inline-block;">
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lijifeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'bWi6klBzJ94DAMDz2tR3Q4V4-gzGzoHsz',
      appKey     : 'bkDWqUctHShLgDzsCF9n70Fx',
      placeholder: "发表一下你的看法",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
